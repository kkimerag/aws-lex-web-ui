AWSTemplateFormatVersion: 2010-09-09
Description: Lambda@Edge function for Origin Request modification

Parameters:
    ResourcePrefix:
        Type: String
        Description: Prefix to use for resource names

Resources:
  EdgeLambdaCleanupRole:
    Type: AWS::IAM::Role
    Properties:
        AssumeRolePolicyDocument:
            Version: '2012-10-17'
            Statement:
                - Effect: Allow
                  Principal:
                      Service: lambda.amazonaws.com
                  Action: sts:AssumeRole
        ManagedPolicyArns:
            - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        Policies:
            - PolicyName: LambdaEdgeCleanup
              PolicyDocument:
                  Version: '2012-10-17'
                  Statement:
                      - Effect: Allow
                        Action:
                            - lambda:DeleteFunction
                            - lambda:GetFunction
                            - lambda:ListFunctions
                            - cloudfront:GetDistribution
                            - cloudfront:ListDistributions
                            - cloudfront:GetDistributionConfig
                        Resource: '*'

  EdgeLambdaCleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
        Handler: index.handler
        Role: !GetAtt EdgeLambdaCleanupRole.Arn
        Code:
            ZipFile: |
                import boto3
                import cfnresponse
                import time
                import json
                
                def handler(event, context):
                    print(f"Received event: {json.dumps(event)}")
                    
                    if event['RequestType'] != 'Delete':
                        print(f"Request type is {event['RequestType']}, sending success")
                        cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                        return
                        
                    function_name = event['ResourceProperties']['FunctionName']
                    print(f"Starting cleanup for function: {function_name}")
                    
                    try:
                        lambda_client = boto3.client('lambda', region_name='us-east-1')
                        cf_client = boto3.client('cloudfront')
                        
                        # First check if function exists
                        try:
                            lambda_client.get_function(FunctionName=function_name)
                            function_exists = True
                        except lambda_client.exceptions.ResourceNotFoundException:
                            print(f"Function {function_name} not found, might be already deleted")
                            function_exists = False
                        
                        if function_exists:
                            print("Checking CloudFront associations...")
                            wait_for_cloudfront_disassociation(cf_client, function_name)
                            
                            print(f"Attempting to delete function {function_name}")
                            wait_and_delete_function(lambda_client, function_name)
                        
                        print("Cleanup completed successfully")
                        cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                        
                    except Exception as e:
                        print(f"Error during cleanup: {str(e)}")
                        # On error, still return success to allow stack deletion to continue
                        cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                            "Message": f"Cleanup encountered an error but stack deletion should continue: {str(e)}"
                        })
                
                def wait_for_cloudfront_disassociation(cf_client, function_name):
                    max_attempts = 20
                    for attempt in range(max_attempts):
                        associated = False
                        try:
                            response = cf_client.list_distributions()
                            if 'Items' not in response['DistributionList']:
                                break
                                
                            for dist in response['DistributionList']['Items']:
                                if check_function_in_distribution(cf_client, dist['Id'], function_name):
                                    associated = True
                                    break
                            
                            if not associated:
                                print("Function no longer associated with any CloudFront distributions")
                                return
                                
                            print(f"Function still associated with CloudFront, waiting... (attempt {attempt + 1}/{max_attempts})")
                            time.sleep(30)
                            
                        except Exception as e:
                            print(f"Error checking CloudFront associations: {str(e)}")
                            time.sleep(30)
                    
                    print("Proceeding with deletion even though CloudFront dissociation could not be confirmed")
                
                def check_function_in_distribution(cf_client, dist_id, function_name):
                    try:
                        response = cf_client.get_distribution_config(Id=dist_id)
                        config = response['DistributionConfig']
                        
                        # Check default cache behavior
                        default_behavior = config.get('DefaultCacheBehavior', {})
                        if check_behavior_for_function(default_behavior, function_name):
                            return True
                            
                        # Check custom cache behaviors
                        cache_behaviors = config.get('CacheBehaviors', {}).get('Items', [])
                        for behavior in cache_behaviors:
                            if check_behavior_for_function(behavior, function_name):
                                return True
                        
                        return False
                    except Exception as e:
                        print(f"Error checking distribution {dist_id}: {str(e)}")
                        return False
                
                def check_behavior_for_function(behavior, function_name):
                    lambda_associations = behavior.get('LambdaFunctionAssociations', {}).get('Items', [])
                    return any(function_name in assoc.get('LambdaFunctionARN', '') 
                             for assoc in lambda_associations)
                
                def wait_and_delete_function(lambda_client, function_name):
                    max_attempts = 10
                    for attempt in range(max_attempts):
                        try:
                            lambda_client.delete_function(FunctionName=function_name)
                            print(f"Successfully deleted function {function_name}")
                            return
                        except lambda_client.exceptions.ResourceNotFoundException:
                            print(f"Function {function_name} already deleted")
                            return
                        except Exception as e:
                            print(f"Delete attempt {attempt + 1} failed: {str(e)}")
                            if "replicated function" in str(e).lower():
                                print("Function is still replicated, waiting...")
                                time.sleep(60)
                            else:
                                raise
                    
                    print(f"Could not delete function {function_name} after {max_attempts} attempts")

        Runtime: python3.9
        Timeout: 900  # 15 minutes
        MemorySize: 128

  EdgeLambdaCleanupTrigger:
    Type: Custom::EdgeLambdaCleanup
    Properties:
        ServiceToken: !GetAtt EdgeLambdaCleanupFunction.Arn
        FunctionName: !Ref EdgeLambdaFunction
              
  EdgeLambdaRole:
      Type: AWS::IAM::Role
      Properties:
          RoleName: !Sub "${ResourcePrefix}-edge-lambda-role"
          AssumeRolePolicyDocument:
              Version: '2012-10-17'
              Statement:
                  - Effect: Allow
                    Principal:
                        Service:
                            - lambda.amazonaws.com
                            - edgelambda.amazonaws.com
                    Action: sts:AssumeRole
          ManagedPolicyArns:
              - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
          Path: "/"

  EdgeLambdaFunction:
      DependsOn: EdgeLambdaCleanupFunction
      Type: AWS::Lambda::Function
      Properties:
          FunctionName: !Sub "${ResourcePrefix}-edge-lambda"
          Code:
              ZipFile: |
                  def lambda_handler(event, context):
                      request = event['Records'][0]['cf']['request']
                      uri = request['uri']
                      
                      headers = request.get('headers', {})
                      
                      referer = headers.get('referer', [{'value': ''}])[0].get('value', '')
                      print(f"Referer: {referer}")
                      
                      try:
                          if referer:
                              folder = referer.split('://')[-1].split('/')[1]
                              uri = uri.lstrip('/')
                              request['uri'] = f"/{folder}/{uri}"
                              print(f"Modified URI: {request['uri']}")
                          else:
                              print("No referer found")
                      except Exception as e:
                          print(f"Error: {e}")
                          
                      return request

          Handler: index.lambda_handler
          Role: !GetAtt EdgeLambdaRole.Arn
          Runtime: python3.9
          Timeout: 5
          MemorySize: 128

  EdgeLambdaVersion:
      Type: AWS::Lambda::Version
      Properties:
          FunctionName: !Ref EdgeLambdaFunction
          Description: v1

Outputs:
    LambdaVersionArn:
        Description: Lambda function version ARN
        Value: !Ref EdgeLambdaVersion
        Export:
            Name: !Sub "${ResourcePrefix}-edge-lambda-version"